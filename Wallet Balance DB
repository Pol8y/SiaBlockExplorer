import requests
import time
import sqlite3
 
def collect_ids(obj):
    ids = []
    if isinstance(obj, dict):
        for key, value in obj.items():
            if key == 'id':
                ids.append(value)
            else:
                ids.extend(collect_ids(value))
    elif isinstance(obj, list):
        for item in obj:
            ids.extend(collect_ids(item))
    return ids

def collect_addresses(obj):
    if isinstance(obj, dict):
        for key, value in obj.items():
            if key == 'address':
                yield value
            else:
                yield from collect_addresses(value)
    elif isinstance(obj, list):
        for item in obj:
            yield from collect_addresses(item)


start_time1 = time.perf_counter()
end_time1 = time.perf_counter()
elapsed_time1 =end_time1 - start_time1

url = 'https://explorer.siagraph.info/api/'
url2 = 'http://localhost:10000/api/'
tip = 'consensus/tip'
blocks = 'blocks/'
wallet = 'addresses/'
balance = '/balance'
trx = 'transactions/'
rtip = requests.get(url2+tip)


start_time1 = time.perf_counter()


open('height.txt','w').close()
if rtip.status_code == 200:
    data = rtip.json()
    height = data.get('height')
    print(height)
    with open('height.txt','w') as file:
        file.write(f'{height}')
    block_id = data.get('id')

all_blocks_transactions_ids = []

for i in range(1,height):
    rtipn = requests.get(url2+tip+'/'+ str(i))
    if rtipn.status_code == 200:
        data = rtipn.json()
        height = data.get('height')
        block_id = data.get('id')
        rblock_id = requests.get(f'{url2}{blocks}{block_id}')
        if rblock_id.status_code == 200:
            data2 = rblock_id.json()
            transactions = data2.get('transactions', [])
            
            block_transaction_ids = []

            for tx in transactions:
                 block_transaction_ids.extend(collect_ids(tx))
            all_blocks_transactions_ids.extend(block_transaction_ids)

end_time1 = time.perf_counter()
elapsed_time1 =end_time1 - start_time1
print(f'{elapsed_time1} seconds to complete first block')
start_time2 = time.perf_counter()

print(f"\nTotal Transactions IDs Collected: {len(all_blocks_transactions_ids)}")



open('transaction_ids.txt','w').close()
with open('transaction_ids.txt', 'w') as file:
    for tx_id in all_blocks_transactions_ids:
        file.write(f'{tx_id}\n')

with open('transaction_ids.txt', 'r') as file:
    all_blocks_transactions_ids = [line.strip() for line in file]

from concurrent.futures import ThreadPoolExecutor, as_completed

def fetch_and_collect(tx):
    tx = tx.strip()
    try:
        rtrx = requests.get(f'{url2}{trx}{tx}', timeout=10)
        if rtrx.status_code == 200:
            data3 = rtrx.json()
            addresses = collect_addresses(data3)
            return addresses
    except Exception as e:
        print(f"Error fetching transaction {tx}: {e}")
    return []

all_addresses = []
wallet_count = 0
MAX_WORKERS = 30  # Adjust based on system capabilities

with ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
    futures = [executor.submit(fetch_and_collect, tx) for tx in all_blocks_transactions_ids]
    for future in as_completed(futures):
        addresses = future.result()
        if addresses:
            all_addresses.extend(addresses)
            wallet_count += 1

end_time2 = time.perf_counter()
elapsed_time2 =end_time2 - start_time2
print(f'{elapsed_time2} seconds to complete second block')
start_time3 = time.perf_counter()

with open('addresses.txt', 'w') as file:
    for address in all_addresses:
        file.write(f'{address}\n')

with open('addresses.txt','r') as file:
    all_wallets = file.readlines()
    all_wallets = sorted(set(line.strip() for line in all_wallets))

print('Total Number of Wallets Collected:', wallet_count)


end_time3 = time.perf_counter()
elapsed_time3 =end_time3 - start_time3
print(f'{elapsed_time3} seconds to complete third block')
start_time4 = time.perf_counter()



conn = sqlite3.connect('wallets.db')
cursor = conn.cursor()
cursor.execute('''
    CREATE TABLE IF NOT EXISTS wallets (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        address TEXT UNIQUE,
        balance REAL
    )
''')
conn.commit

open('wallets_balance.txt','w').close()

for wx in all_wallets:
    wx = wx.strip()
    rwx = requests.get(f'{url2}{wallet}{wx}{balance}')
    if rwx.status_code == 200:
        data4 = rwx.json()
        siacoin_balance = data4.get('unspentSiacoins')
        actual_balance = float(int(siacoin_balance))/ 1e24
        try:
            cursor.execute('INSERT INTO wallets (address, balance) VALUES (?, ?)', (wx,actual_balance))
        except sqlite3.IntegrityError:
            cursor.execute('UPDATE wallets SET balance = ? WHERE address = ?', (actual_balance,wx))
conn.commit()

cursor.execute('SELECT address, balance FROM wallets ORDER BY balance ASC')
results = cursor.fetchall()

for wx, actual_balance in results:
    if actual_balance != 0.0:
        print(f'Address: {wx}, Balance: {actual_balance}')


end_time4 = time.perf_counter()
elapsed_time4 =end_time4 - start_time4
print(f'{elapsed_time1} seconds to complete first block')
print(f'{elapsed_time2} seconds to complete second block')
print(f'{elapsed_time3} seconds to complete third block')
print(f'{elapsed_time4} seconds to complete fourth block')
print(height)
